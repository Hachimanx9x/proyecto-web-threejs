<script src="/librerias/threejs/three.js"></script>

	<script src="/librerias/Projector.js"></script>
		<script src="/librerias/CanvasRenderer.js"></script>

             <script src="/librerias/Chart/chart.js"></script>
            <script src="/librerias/Detector.js"></script>
          <div id="info">
			grafico como textura <a href="/">volver</a>
		</div>
             <script>
		if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
            var canvas1 ;
			var camera, scene, renderer, mesh, mesh2,obj, material;
			var drawStartPos = new THREE.Vector2();

			init();
			setupCanvasDrawing();
			animate();

			function init() {
                canvas1 = document.createElement( 'canvas' );
                 canvas1.height=120;
                  canvas1.width=120;
                  canvas1.style.backgroundColor="#ffffff"; 
                document.body.appendChild( canvas1 );

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.z = 250;

				scene = new THREE.Scene();

				material = new THREE.MeshBasicMaterial();
				obj = new THREE.Object3D(); 

                	// skybox
				var path = '/publico/texturas/Bridge2/';
				var format = '.jpg';
				var envMap = new THREE.CubeTextureLoader().load( [
					path + 'posx' + format, path + 'negx' + format,
					path + 'posy' + format, path + 'negy' + format,
					path + 'posz' + format, path + 'negz' + format
				] );             
          

                scene = new THREE.Scene();
                scene.background = envMap ;
				light = new THREE.HemisphereLight( 0xbbbbff, 0x444422 );
				light.position.set( 0, 1, 0 );
				scene.add( light );

              
             //   material.map = new THREE.CanvasTexture(canvas1 );

				mesh = new THREE.Mesh( new THREE.BoxBufferGeometry( 200, 200, 200 ), material );
				mesh2 = new THREE.Mesh( new THREE.BoxBufferGeometry( 200, 200, 200 ),new THREE.MeshBasicMaterial( { color: 0xfffffff } ) );
				obj.add(mesh); obj.add(mesh2); 
				scene.add( obj );


                
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );

			}

			// Sets up the drawing canvas and adds it as the material map

			function setupCanvasDrawing() {

				// get canvas and context

				var drawingCanvas = canvas1 ; 
              

				;
               
                var marksData = {
                        labels: ["English", "Maths", "Physics", "Chemistry", "Biology", "History"],
					
                        datasets: [{
                            label: "Student A",
                            backgroundColor: "rgba(200,0,0,0.2)",
                            data: [65, 75, 70, 80, 60, 80]
                        }, {
                            label: "Student B",
                            backgroundColor: "rgba(0,0,200,0.2)",
                            data: [54, 65, 60, 70, 70, 75]
                        }]
                        };
			
						
                        var radarChart = new Chart(drawingCanvas, {           type: 'radar',                   data: marksData,               });
                     
               // drawingCanvas.style.backgroundColor="white"; 
				
				// set canvas as material.map (this could be done to any map, bump, displacement etc.)
               
				material.map = new THREE.CanvasTexture( drawingCanvas );
              //  material.side = THREE.BackSide; 
                material.overdraw= 0.5; 
				material.transparent= true; 



			}

		

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				obj.rotation.x += 0.01;
				obj.rotation.y += 0.01;
				//esto solo se debe ejecutar cuando se actualiza el canvas pero se deja aqui por razones de pereza
                material.map.needsUpdate = true;
				renderer.render( scene, camera );

			}
		</script>
